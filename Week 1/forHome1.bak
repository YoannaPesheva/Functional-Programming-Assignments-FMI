#lang racket

#|
Problem 1
What are closures?
Closures are functions that can remember and access the scope around them.

What makes closures special?
When  we leave a function (in a normal function stack), the scope is forgotten. From the other side, when we create a closure,
the scope of it stays in the memory as long as the closure still exists, which means we can return a closure from a parent
function and still have access to all the data that the parent function had access to, even if the closure is called
from a different scope later on.

What are higher order functions?
Higher order functions are functions that work with other functions to perform an action. It basically takes other functions
as arguments and it can return a function as a result.

What are examples of higher order functions?
filter(), sort(), map().

What are pure functions?
A pure function is a function that will always return the same output when given the same input(and it will not affect
anything else). This happens when we get rid of the side effects(immutability). It is typically enforced by removing
the variability of variables.

What is immutability?
Immutability is how we create values and objects(by initializing them and then not modifying them in any way). Here, side
effects need to be prevented from happening (they happen when we allow unpredictable state from outside the scope of a
function to affect it).

What is currying?
Currying brings up multiple arguments of a function into their own function calls that is then chained together. It achieves
it by using closures (because they have scope memory).

What are the three core values of being purely functional?
Declarative, deterministic and unchanging.
|#


; Problem 2
(define (my-gcd x y)
  (cond
    [(= x 0) y] ;i don't think it ever gets here, because the remainder(that eventually becomes 0) always comes on second place(so as y), but whatever :D
    [(= y 0) x]
    [else (my-gcd y (remainder x y))]
    )
  )

(= (my-gcd 13 5) 1)
(= (my-gcd 13 1235) 13)


; Problem 3
  ; Using logical and boolean operators only
(define (leap-year-one-line? year)
  (or (= 0 (remainder year 400)) ; year/400==0
       (and ; year/100!=0 and year/4==0
          (= 0 (remainder year 4))
          (not (= 0 (remainder year 100))
       )
   )
 )
)

(equal? (leap-year-one-line? 2020) #t)
(equal? (leap-year-one-line? 1988) #t)
(equal? (leap-year-one-line? 1600) #t)
(equal? (leap-year-one-line? 2400) #t)
(equal? (leap-year-one-line? 2023) #f)
(equal? (leap-year-one-line? 1700) #f)
(equal? (leap-year-one-line? 1800) #f)
(equal? (leap-year-one-line? 2100) #f)

  ; Using guards
(define (is-leap-year-guards? year)
  (cond
    [(= 0 (remainder year 400)) #t]
    [(= 0 (remainder year 100)) #f]
    [(= 0 (remainder year 4)) #t]
    [else #f] ; for the years that are not divisible by 4, 100 and 400
    )  
  )

(equal? (is-leap-year-guards? 2020) #t)
(equal? (is-leap-year-guards? 1988) #t)
(equal? (is-leap-year-guards? 1600) #t)
(equal? (is-leap-year-guards? 2400) #t)
(equal? (is-leap-year-guards? 2023) #f)
(equal? (is-leap-year-guards? 1700) #f)
(equal? (is-leap-year-guards? 1800) #f)
(equal? (is-leap-year-guards? 2100) #f)


;Problem 4
(define (can-carry? c k w)
  (cond
    [(< c 0) (error "The number of products was negative")]
    [(< k 0) (error "John's hosting capacity was negative")]
    [(< w 0) (error "The weight of a product was negative")]
    [else
     ; w*c - The amount of kilograms John wants to carry
     (>= 0 (- (* w c) k)) 
     ]
    )
 )

(equal? (can-carry? 5 15 3) #t)
(equal? (can-carry? 1 5 4) #t)
(equal? (can-carry? 13 25 2) #f)
(equal? (can-carry? 24 104.44 21.12) #f)
(equal? (can-carry? 51 34.75 19.852) #f)
(equal? (can-carry? 42 95.11 0.51) #t)

; (can-carry? -13 25 2) ; error: The number of products was negative
; (can-carry? 13 -25 2) ; error: John's hosting capacity was negative
; (can-carry? 13 25 -2) ; error: The weight of a product was negative


;Problem 5
(define (growing-plant up-speed down-speed desired-height)
  (define (count-days current-height days) ; helper function
    (cond
      [(>= (+ current-height up-speed) desired-height) (+ days 1)]
      [else
       (count-days (- (+ current-height up-speed) down-speed)(+ days 1)) ; if it doesn't reach it during the day, we need to not only increase, but also decrease
       ]
     )
    )
  (count-days 0 0) ; calling the helper function in the main function
  )

(= (growing-plant 5 2 5) 1)
(= (growing-plant 5 2 6) 2)
(= (growing-plant 10 9 4) 1)
(= (growing-plant 100 10 910) 10)


; Problem 6
(define (snail column-height crawling-up crawling-down)
  (define (count-days current-height days)
    (cond
      [(>= (+ current-height crawling-up) column-height) (+ days 1)]
      [else
       (count-days (- (+ current-height crawling-up) crawling-down)(+ days 1)) ; same as the previous one
       ]
     )
    )
  (count-days 0 0)
  )

(= (snail 3 2 1) 2)
(= (snail 10 3 1) 5)
(= (snail 10 3 2) 8)
(= (snail 100 20 5) 7)
(= (snail 5 10 3) 1)


; Problem 7
(define (rev n)
  (define (helper copy-n res)
    (cond
      [(zero? copy-n) res]
      [else
       (helper (quotient n 10) (+ (remainder n 10) (* res 10))) ; copy=n becomes n without the last digit, result needs to be multiplied by 10 in reverse + last digit added
      ]
      )
    )
  (helper n 0) ; starting from 0 because the first digit we put shouldn't be multiplied by 10
 )

(= (rev 1) 1)
(= (rev 123) 321)
(= (rev 987654321) 123456789)



